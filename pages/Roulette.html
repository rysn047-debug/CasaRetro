<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CasaRetro Roulette - Pixel Edition</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    
    <script>
        // Tailwind config with arcade style color palette
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        'pixel': ['VT323', 'monospace'],
                    },
                    colors: {
                        'arcade-black': '#1a1a1a',
                        'arcade-bg': '#2c2c3a',
                        'arcade-blue': '#00a8f3',
                        'arcade-pink': '#f72585',
                        'arcade-purple': '#7209b7',
                        'arcade-gray': '#4a4a5a',
                        'arcade-light': '#f0f0f0',
                    },
                    boxShadow: {
                        'pixel-sm': '4px 4px 0px 0px rgba(0,0,0,1)',
                        'pixel-sm-inset': 'inset 4px 4px 0px 0px rgba(0,0,0,0.5)',
                        'pixel-md': '6px 6px 0px 0px rgba(0,0,0,1)',
                        'pixel-md-inset': 'inset 6px 6px 0px 0px rgba(0,0,0,0.5)',
                        'neon': '0 0 5px #f72585, 0 0 10px #f72585, 0 0 15px #f72585',
                    }
                }
            }
        }
    </script>

    <style>
        /* Custom styles for retro/pixel aesthetic */
        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'pixel', monospace;
            background-color: #1a1a1a;
            background-image: 
                linear-gradient(rgba(22, 6, 37, 0.9), rgba(44, 44, 58, 0.9)),
                url('https://www.transparenttextures.com/patterns/carbon-fibre.png');
            color: #f0f0f0;
            text-shadow: 2px 2px #000;
        }

        /* Main container with a pixelated border */
        .main-container {
            border: 4px solid #1a1a1a;
            box-shadow: 
                inset 0 0 0 4px #4a4a5a,
                0 0 20px rgba(247, 37, 133, 0.3);
        }

        /* Roulette pointer style */
        .wheel-container::before {
            content: '';
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 20px solid transparent;
            border-right: 20px solid transparent;
            border-top: 30px solid #f72585;
            filter: drop-shadow(0 4px 0 #000);
            z-index: 10;
        }
        
        #roulette-wheel {
            border-radius: 50%;
            border: 8px solid #1a1a1a;
            box-shadow: inset 0 0 0 8px #4a4a5a, 0 0 25px rgba(0, 168, 243, 0.5);
        }

        /* Spin button with arcade button style */
        #spin-button {
            width: 80px;
            height: 80px;
            background-color: #f72585;
            border: 4px solid #1a1a1a;
            box-shadow: 
                inset 0 0 0 4px #4a4a5a,
                0 8px 0 0 #7209b7;
            transition: all 0.1s ease-in-out;
        }

        #spin-button:active {
            transform: translate(-50%, -50%) translateY(4px);
            box-shadow: 
                inset 0 0 0 4px #4a4a5a,
                0 4px 0 0 #7209b7;
        }
        
        /* General styles for inputs and buttons */
        .pixel-input, .pixel-button {
            border: 4px solid #1a1a1a;
            box-shadow: inset 0 0 0 4px #4a4a5a;
            background-color: #2c2c3a;
            padding: 10px 16px;
            font-size: 1.25rem; /* 20px */
            transition: all 0.2s ease;
        }

        .pixel-input:focus {
            outline: none;
            box-shadow: inset 0 0 0 4px #00a8f3;
        }
        
        .pixel-button {
            cursor: pointer;
            box-shadow: 4px 4px 0px 0px #1a1a1a;
        }
        
        .pixel-button:hover {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0px 0px #1a1a1a;
        }

        .pixel-button:active {
            transform: translate(4px, 4px);
            box-shadow: 0px 0px 0px 0px #1a1a1a;
        }

        /* Game cover styles */
        .cover-item img {
            border: 4px solid #1a1a1a;
            box-shadow: inset 0 0 0 4px #4a4a5a;
            transition: all 0.2s ease;
            image-rendering: pixelated;
        }

        .cover-item.in-wheel img {
            opacity: 1;
            transform: scale(1.05);
            box-shadow: inset 0 0 0 4px #00a8f3, 0 0 15px rgba(0, 168, 243, 0.7);
        }
        
        .cover-item:not(.in-wheel) img {
            opacity: 0.4;
            filter: grayscale(80%);
        }

        /* NEW: Style for the name overlay on the main game library covers */
        .cover-item-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(0, 0, 0, 0.7);
            color: #f0f0f0;
            padding: 4px;
            text-align: center;
            font-size: 1rem;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            pointer-events: none; /* So it doesn't block clicks */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin: 4px; /* To fit inside the border */
        }

        .cover-item.group:hover .cover-item-overlay {
            opacity: 1;
        }


        /* Custom file input style */
        input[type="file"]::file-selector-button {
            font-family: 'pixel', monospace;
            text-shadow: 2px 2px #000;
            border: 4px solid #1a1a1a;
            background-color: #4a4a5a;
            color: #f0f0f0;
            padding: 10px 16px;
            cursor: pointer;
            box-shadow: 4px 4px 0px 0px #1a1a1a;
            transition: all 0.2s ease;
        }
        input[type="file"]::file-selector-button:hover {
            background-color: #7209b7;
        }
        
        /* Winner modal style */
        .modal-content {
            border: 4px solid #1a1a1a;
            box-shadow: inset 0 0 0 4px #4a4a5a, 0 0 30px rgba(247, 37, 133, 0.5);
        }

        /* --- STYLES FOR DRIVE GALLERY --- */

        /* Loading spinner style */
        .loader {
            border: 4px solid #4a4a5a;
            border-top: 4px solid #00a8f3;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Styles for gallery items for consistent sizing */
        #drive-gallery-container .gallery-item {
            width: 100%;
            height: 212px; /* Approximate height of roulette covers */
            overflow: hidden;
            border: 4px solid #1a1a1a;
            box-shadow: inset 0 0 0 4px #4a4a5a;
            background-color: #1a1a1a; /* Darker background for letterboxing */
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative; /* Needed for positioning the view icon */
        }

        #drive-gallery-container .gallery-item img {
            width: 100%;
            height: 100%;
            object-fit: contain; /* This ensures the image fits without being cropped */
            cursor: pointer;
            transition: transform 0.2s ease-in-out;
            image-rendering: pixelated; /* Keeps pixel art sharp */
        }

        #drive-gallery-container .gallery-item:hover img {
            transform: scale(1.05);
        }

        /* Style for the view icon */
        .view-icon {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 32px;
            height: 32px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #4a4a5a;
            color: #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            z-index: 10;
        }
        
        /* Style for the name overlay */
        .image-name-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(0, 0, 0, 0.7);
            color: #f0f0f0;
            padding: 4px;
            text-align: center;
            font-size: 1rem;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            pointer-events: none; /* So it doesn't block clicks on the image */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .gallery-item:hover .view-icon,
        .gallery-item:hover .image-name-overlay {
            opacity: 1;
        }

        /* Full-size image viewer modal styles */
        .image-viewer-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.9);
        }
        .viewer-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 90%;
            max-height: 90%;
        }
        .viewer-content img {
            max-width: 100%;
            max-height: 90vh;
            object-fit: contain;
        }
        .close-viewer {
            position: absolute;
            top: 15px;
            right: 35px;
            color: #fff;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
        }
    </style>
</head>
<body class="font-pixel text-arcade-light text-xl">

    <div class="container mx-auto p-4 md:p-8 max-w-6xl">
        
        <header class="text-center mb-12">
            <h1 class="text-6xl md:text-8xl font-black uppercase text-arcade-pink tracking-widest" style="text-shadow: 4px 4px #7209b7;">
                CasaRetro Roulette
            </h1>
            <p class="text-arcade-blue mt-4 text-2xl">SELECT YOUR FIGHTER</p>
        </header>

        <main class="flex flex-col lg:flex-row items-center justify-center gap-12">
            
            <div class="flex flex-col items-center">
                <div class="wheel-container relative w-[320px] h-[320px] sm:w-[500px] sm:h-[500px]">
                    <canvas id="roulette-wheel" width="500" height="500"></canvas>
                    <button id="spin-button" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 rounded-full z-10"></button>
                </div>
            </div>

            <section class="w-full max-w-md bg-arcade-bg p-6 main-container">
                <h2 class="text-3xl font-bold mb-6 text-center uppercase">INSERT COIN</h2>
                <div class="flex flex-col gap-4">
                    <input type="text" id="game-name-input" placeholder="Game Name..." class="pixel-input w-full">
                    <input type="file" id="game-cover-input" accept="image/*" class="text-arcade-gray file:text-xl">
                </div>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mt-6">
                    <button id="add-game-button" class="pixel-button bg-arcade-blue text-arcade-black">ADD GAME</button>
                    <button id="reset-button" class="pixel-button bg-arcade-pink text-arcade-black">CLEAR WHEEL</button>
                </div>
            </section>
        </main>

        <footer class="mt-16 bg-arcade-bg p-6 main-container">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-4xl font-bold uppercase">Game Library</h2>
                <button id="open-drive-gallery-button" class="pixel-button bg-arcade-purple text-arcade-light">DRIVE GALLERY</button>
            </div>
            <div id="covers-gallery" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-4">
            </div>
        </footer>

    </div>
    
    <div id="winner-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center p-4 hidden z-50">
        <div class="modal-content bg-arcade-bg text-center p-8 max-w-md w-full">
            <h2 class="text-4xl font-bold text-arcade-blue mb-4 uppercase">WINNER!</h2>
            <img id="winner-cover" src="" alt="Winner cover" class="w-full mb-4" style="aspect-ratio: 3 / 4; object-fit: cover; border: 4px solid #1a1a1a; box-shadow: inset 0 0 0 4px #4a4a5a;">
            <h3 id="winner-name" class="text-5xl font-black uppercase text-arcade-pink" style="text-shadow: 3px 3px #7209b7;"></h3>
            <button id="close-modal-button" class="mt-8 pixel-button bg-arcade-purple text-arcade-light">PLAY AGAIN</button>
        </div>
    </div>

    <div id="drive-gallery-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center p-4 hidden z-40">
        <div class="modal-content bg-arcade-bg p-8 max-w-4xl w-full h-5/6 flex flex-col">
            <div class="flex justify-between items-center mb-4">
                <div class="flex items-center gap-4">
                    <button id="drive-back-button" class="pixel-button bg-arcade-gray text-arcade-light hidden">&lt; Back</button>
                    <h2 id="drive-modal-title" class="text-4xl font-bold text-arcade-blue uppercase">DRIVE GALLERY</h2>
                </div>
                <button id="close-drive-modal-button" class="text-4xl hover:text-arcade-pink">&times;</button>
            </div>
            <div id="drive-gallery-container" class="flex-grow overflow-y-auto grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 pr-4">
            </div>
            <div id="drive-message-container" class="text-center mt-4"></div>
        </div>
    </div>

    <div id="image-viewer-modal" class="image-viewer-modal">
        <span class="close-viewer">&times;</span>
        <div class="viewer-content">
            <img id="viewer-img" src="" alt="Full-size view">
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- ROULETTE DOM ELEMENT REFERENCES ---
            const canvas = document.getElementById('roulette-wheel');
            const ctx = canvas.getContext('2d');
            const spinButton = document.getElementById('spin-button');
            const addGameButton = document.getElementById('add-game-button');
            const gameNameInput = document.getElementById('game-name-input');
            const gameCoverInput = document.getElementById('game-cover-input');
            const coversGallery = document.getElementById('covers-gallery');
            const resetButton = document.getElementById('reset-button');
            const winnerModal = document.getElementById('winner-modal');
            const winnerCover = document.getElementById('winner-cover');
            const winnerName = document.getElementById('winner-name');
            const closeModalButton = document.getElementById('close-modal-button');

            // --- ROULETTE APPLICATION STATE ---
            let allGames = [];
            let gamesInWheel = [];
            const wheelColors = ["#f72585", "#7209b7", "#00a8f3", "#4a4a5a"];
            let startAngle = 0;
            let arc = 0;
            let isSpinning = false;
            let spinTimeout = null;
            let audioContext;
            let lastTickAngle = 0;

            // --- ROULETTE CORE FUNCTIONS ---
            
            function drawRoulette() {
                if (!canvas.getContext) return;
                
                const outsideRadius = 250;
                const textRadius = 180;
                const insideRadius = 0;
                const imageRadius = 110;

                arc = gamesInWheel.length > 0 ? 2 * Math.PI / gamesInWheel.length : 2 * Math.PI;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (gamesInWheel.length === 0) {
                    ctx.fillStyle = '#2c2c3a';
                    ctx.beginPath();
                    ctx.arc(250, 250, outsideRadius, 0, 2 * Math.PI, false);
                    ctx.fill();
                    ctx.save();
                    ctx.fillStyle = '#f0f0f0';
                    ctx.font = '30px VT323, monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('ADD GAMES TO THE WHEEL', 250, 250);
                    ctx.restore();
                    return;
                }

                gamesInWheel.forEach((game, i) => {
                    const angle = startAngle + i * arc;
                    ctx.fillStyle = wheelColors[i % wheelColors.length];

                    ctx.beginPath();
                    ctx.arc(250, 250, outsideRadius, angle, angle + arc, false);
                    ctx.arc(250, 250, insideRadius, angle + arc, angle, true);
                    ctx.strokeStyle = '#1a1a1a';
                    ctx.lineWidth = 8;
                    ctx.stroke();
                    ctx.fill();
                    ctx.save();

                    ctx.fillStyle = '#f0f0f0';
                    ctx.font = 'bold 24px VT323, monospace';
                    ctx.shadowColor = "black";
                    ctx.shadowOffsetX = 2;
                    ctx.shadowOffsetY = 2;
                    ctx.shadowBlur = 0;
                    
                    ctx.translate(
                        250 + Math.cos(angle + arc / 2) * textRadius,
                        250 + Math.sin(angle + arc / 2) * textRadius
                    );
                    ctx.rotate(angle + arc / 2 + Math.PI / 2);
                    const text = game.name.toUpperCase();
                    ctx.fillText(text, -ctx.measureText(text).width / 2, 0);
                    
                    ctx.restore();
                    ctx.save();

                    if (game.image) {
                         ctx.translate(
                            250 + Math.cos(angle + arc / 2) * imageRadius,
                            250 + Math.sin(angle + arc / 2) * imageRadius
                        );
                        ctx.rotate(angle + arc / 2 + Math.PI / 2);
                        ctx.drawImage(game.image, -30, -40, 60, 80);
                        ctx.strokeStyle = '#f0f0f0';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(-30, -40, 60, 80);
                    }
                    ctx.restore();
                });
            }

            function displayCoverInGallery(game) {
                const coverDiv = document.createElement('div');
                coverDiv.className = 'cover-item relative group';
                coverDiv.dataset.name = game.name;

                const coverImg = document.createElement('img');
                coverImg.src = game.coverUrl;
                coverImg.alt = game.name;
                coverImg.className = 'w-full h-auto object-cover cursor-pointer';
                coverImg.onerror = () => {
                    coverImg.src = 'https://placehold.co/275x387/2c2c3a/f0f0f0?text=Error';
                };
                
                const deleteButton = document.createElement('button');
                deleteButton.className = 'delete-button absolute top-2 right-2 w-8 h-8 bg-arcade-pink text-arcade-black text-2xl flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity duration-200 pixel-button';
                deleteButton.innerHTML = '&times;';
                deleteButton.style.boxShadow = '2px 2px 0px #000';

                deleteButton.addEventListener('click', (event) => {
                    event.stopPropagation();
                    handleDeleteGame(game.name);
                });

                // NEW: Create the name overlay for the main library
                const nameOverlay = document.createElement('div');
                nameOverlay.className = 'cover-item-overlay';
                nameOverlay.textContent = game.name;

                coverDiv.appendChild(coverImg);
                coverDiv.appendChild(deleteButton);
                coverDiv.appendChild(nameOverlay); // Add the overlay
                
                coverDiv.addEventListener('click', () => {
                    toggleGameInWheel(game.name);
                });

                coversGallery.appendChild(coverDiv);
            }
            
            function handleAddGame() {
                const name = gameNameInput.value.trim();
                const file = gameCoverInput.files[0];

                if (name && file) {
                    if (allGames.some(game => game.name.toLowerCase() === name.toLowerCase())) {
                        gameNameInput.style.boxShadow = 'inset 0 0 0 4px #f72585';
                        setTimeout(() => { gameNameInput.style.boxShadow = 'inset 0 0 0 4px #4a4a5a'; }, 2000);
                        return;
                    }

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const originalImage = new Image();
                        originalImage.onload = () => {
                            const resizeCanvas = document.createElement('canvas');
                            const targetWidth = 275;
                            const targetHeight = 387;
                            resizeCanvas.width = targetWidth;
                            resizeCanvas.height = targetHeight;
                            
                            const resizeCtx = resizeCanvas.getContext('2d');
                            resizeCtx.drawImage(originalImage, 0, 0, targetWidth, targetHeight);

                            const resizedCoverUrl = resizeCanvas.toDataURL(file.type);
                            const imageForWheel = new Image();
                            imageForWheel.onload = () => {
                                const newGame = {
                                    name: name,
                                    image: imageForWheel,
                                    coverUrl: resizedCoverUrl
                                };
                                allGames.push(newGame);
                                if (!gamesInWheel.some(g => g.name === newGame.name)) {
                                    gamesInWheel.push(newGame);
                                }
                                displayCoverInGallery(newGame);
                                saveGamesToStorage();
                                updateGalleryVisuals();
                                drawRoulette();
                                gameNameInput.value = '';
                                gameCoverInput.value = '';
                            };
                            imageForWheel.src = resizedCoverUrl;
                        };
                        originalImage.src = e.target.result;
                    }
                    reader.readAsDataURL(file);
                }
            }
            
            function handleDeleteGame(gameName) {
                allGames = allGames.filter(game => game.name !== gameName);
                gamesInWheel = gamesInWheel.filter(game => game.name !== gameName);
                const coverElement = document.querySelector(`.cover-item[data-name="${gameName}"]`);
                if (coverElement) {
                    coverElement.remove();
                }
                saveGamesToStorage();
                drawRoulette();
            }

            function toggleGameInWheel(gameName) {
                const gameIndexInWheel = gamesInWheel.findIndex(game => game.name === gameName);
                if (gameIndexInWheel > -1) {
                    gamesInWheel.splice(gameIndexInWheel, 1);
                } else {
                    const gameToAdd = allGames.find(game => game.name === gameName);
                    if (gameToAdd) {
                        gamesInWheel.push(gameToAdd);
                    }
                }
                updateGalleryVisuals();
                drawRoulette();
            }

            function updateGalleryVisuals() {
                const galleryItems = document.querySelectorAll('.cover-item');
                galleryItems.forEach(item => {
                    const gameName = item.dataset.name;
                    if (gamesInWheel.some(game => game.name === gameName)) {
                        item.classList.add('in-wheel');
                    } else {
                        item.classList.remove('in-wheel');
                    }
                });
            }

            function saveGamesToStorage() {
                const storableList = allGames.map(game => ({
                    name: game.name,
                    coverUrl: game.coverUrl
                }));
                localStorage.setItem('fgcRouletteGames', JSON.stringify(storableList));
            }

            function loadGamesFromStorage() {
                const savedGames = localStorage.getItem('fgcRouletteGames');
                if (savedGames) {
                    const parsedGames = JSON.parse(savedGames);
                    let loadedImagesCount = 0;
                    if (parsedGames.length === 0) {
                        drawRoulette();
                        return;
                    }
                    parsedGames.forEach(savedGame => {
                        const img = new Image();
                        img.src = savedGame.coverUrl;
                        img.onload = () => {
                            const newGame = {
                                name: savedGame.name,
                                image: img,
                                coverUrl: savedGame.coverUrl
                            };
                            allGames.push(newGame);
                            gamesInWheel.push(newGame);
                            displayCoverInGallery(newGame);
                            loadedImagesCount++;
                            if (loadedImagesCount === parsedGames.length) {
                                drawRoulette();
                                updateGalleryVisuals();
                            }
                        };
                        img.onerror = () => {
                            loadedImagesCount++;
                             if (loadedImagesCount === parsedGames.length) {
                                drawRoulette();
                                updateGalleryVisuals();
                            }
                        };
                    });
                } else {
                    drawRoulette();
                }
            }

            function handleReset() {
                gamesInWheel = [];
                updateGalleryVisuals();
                drawRoulette();
            }

            function playSound(type, duration = 0.05, frequency = 800, gain = 0.1) {
                 if (!audioContext) return;
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.type = type;
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                gainNode.gain.setValueAtTime(gain, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            }

            function rotateWheel(spinTime, spinTimeTotal, spinAngleStart) {
                spinTime += 30;
                if (spinTime >= spinTimeTotal) {
                    stopRotateWheel();
                    return;
                }
                const spinAngle = spinAngleStart - easeOut(spinTime, 0, spinAngleStart, spinTimeTotal);
                startAngle += (spinAngle * Math.PI / 180);
                if (startAngle - lastTickAngle > arc) {
                    playSound('square', 0.05, 800, 0.05);
                    lastTickAngle += arc;
                }
                drawRoulette();
                spinTimeout = requestAnimationFrame(() => rotateWheel(spinTime, spinTimeTotal, spinAngleStart));
            }
            
            function stopRotateWheel() {
                cancelAnimationFrame(spinTimeout);
                isSpinning = false;
                spinButton.disabled = false;
                if (gamesInWheel.length === 0) return;
                playSound('sine', 0.5, 900, 0.2);
                const degrees = startAngle * 180 / Math.PI + 90;
                const arcd = arc * 180 / Math.PI;
                const index = Math.floor((360 - degrees % 360) / arcd);
                const winner = gamesInWheel[index];
                winnerName.textContent = winner.name;
                winnerCover.src = winner.coverUrl;
                winnerModal.classList.remove('hidden');
            }

            function easeOut(t, b, c, d) {
                const ts = (t /= d) * t;
                const tc = ts * t;
                return b + c * (tc + -3 * ts + 3 * t);
            }

            function handleSpin() {
                if (isSpinning || gamesInWheel.length < 2) return;
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                isSpinning = true;
                spinButton.disabled = true;
                const spinAngleStart = Math.random() * 10 + 10;
                const spinTimeTotal = Math.random() * 16000 + 20000; 
                lastTickAngle = startAngle;
                rotateWheel(0, spinTimeTotal, spinAngleStart);
            }
            
            // --- ROULETTE EVENT LISTENERS ---
            addGameButton.addEventListener('click', handleAddGame);
            resetButton.addEventListener('click', handleReset);
            spinButton.addEventListener('click', handleSpin);
            closeModalButton.addEventListener('click', () => winnerModal.classList.add('hidden'));
            winnerModal.addEventListener('click', (e) => {
                if (e.target === winnerModal) {
                    winnerModal.classList.add('hidden');
                }
            });

            // --- INITIALIZATION ---
            loadGamesFromStorage();


            // ========================================================================
            // --- GOOGLE DRIVE GALLERY LOGIC ---
            // ========================================================================

            // --- CONFIGURATION ---
            // Replace with your Google Drive API Key
            const apiKey = 'AIzaSyD-0tLu5kAO9aeSp-5sHoyRcW13_dJXApM'; // <-- ¡¡¡RECUERDA PONER TU API KEY!!!
            // Replace with your Google Drive Folder ID or the full URL
            const parentFolderId = '1kkBXX53FnaVtDcS9bKXOpZnytiuowCV2'; // <-- ¡¡¡RECUERDA PONER TU FOLDER ID PRINCIPAL!!!
            // --- END CONFIGURATION ---

            // --- DRIVE GALLERY DOM REFERENCES ---
            const openDriveGalleryButton = document.getElementById('open-drive-gallery-button');
            const driveGalleryModal = document.getElementById('drive-gallery-modal');
            const closeDriveModalButton = document.getElementById('close-drive-modal-button');
            const driveGalleryContainer = document.getElementById('drive-gallery-container');
            const driveMessageContainer = document.getElementById('drive-message-container');
            const imageViewerModal = document.getElementById('image-viewer-modal');
            const viewerImg = document.getElementById('viewer-img');
            const closeViewerBtn = document.querySelector('.close-viewer');
            const driveModalTitle = document.getElementById('drive-modal-title');
            const driveBackButton = document.getElementById('drive-back-button');

            // --- DRIVE GALLERY FUNCTIONS ---
            
            function showDriveLoader() {
                driveGalleryContainer.innerHTML = `<div class="col-span-full flex justify-center items-center h-full"><div class="loader"></div></div>`;
                driveMessageContainer.innerHTML = '';
            }

            function showDriveMessage(text, isError = false) {
                driveGalleryContainer.innerHTML = '';
                const messageColor = isError ? 'text-arcade-pink' : 'text-arcade-gray';
                driveMessageContainer.innerHTML = `<p class="${messageColor} text-2xl">${text}</p>`;
            }

            function getThumbnailUrl(thumbnailLink) {
                if (!thumbnailLink) return null;
                return thumbnailLink.replace(/=s\d+/, '=s800');
            }
            
            async function loadDriveFolders() {
                if (apiKey.includes('...') || parentFolderId.includes('...')) {
                    showDriveMessage('Please configure your API Key and parent Folder ID.', true);
                    return;
                }

                showDriveLoader();
                driveModalTitle.textContent = 'DRIVE GALLERY';
                driveBackButton.classList.add('hidden');
                
                driveGalleryContainer.className = 'flex-grow overflow-y-auto grid grid-cols-1 sm:grid-cols-2 gap-4 pr-4';

                const query = `'${parentFolderId}' in parents and mimeType = 'application/vnd.google-apps.folder'`;
                const apiUrl = `https://www.googleapis.com/drive/v3/files?q=${encodeURIComponent(query)}&fields=files(id,name)&key=${apiKey}`;

                try {
                    const response = await fetch(apiUrl);
                    if (!response.ok) throw new Error(`API error: ${response.statusText}`);
                    
                    const data = await response.json();
                    driveGalleryContainer.innerHTML = '';

                    if (data.files && data.files.length > 0) {
                        data.files.forEach((folder, index) => {
                            const folderButton = document.createElement('button');
                            
                            const isEven = index % 2 === 0;
                            const bgColor = isEven ? 'bg-arcade-pink' : 'bg-arcade-blue';
                            const textColor = 'text-arcade-black';

                            folderButton.className = `pixel-button ${bgColor} ${textColor} text-2xl`;
                            
                            folderButton.textContent = folder.name;
                            folderButton.onclick = () => loadImagesFromFolder(folder.id, folder.name);
                            driveGalleryContainer.appendChild(folderButton);
                        });
                    } else {
                        showDriveMessage('No folders found in the main directory.');
                    }
                } catch (error) {
                    console.error('Error fetching folders:', error);
                    showDriveMessage(`Error loading folders: ${error.message}`, true);
                }
            }

            async function loadImagesFromFolder(folderId, folderName) {
                showDriveLoader();
                driveModalTitle.textContent = folderName.toUpperCase();
                driveBackButton.classList.remove('hidden');

                driveGalleryContainer.className = 'flex-grow overflow-y-auto grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 pr-4';

                const query = `'${folderId}' in parents and mimeType contains 'image/'`;
                const apiUrl = `https://www.googleapis.com/drive/v3/files?q=${encodeURIComponent(query)}&fields=files(id,name,mimeType,thumbnailLink)&key=${apiKey}`;

                try {
                    const response = await fetch(apiUrl);
                    if (!response.ok) throw new Error(`API error: ${response.statusText}`);

                    const data = await response.json();
                    driveGalleryContainer.innerHTML = '';

                    if (data.files && data.files.length > 0) {
                        data.files.forEach(file => {
                            const galleryItem = document.createElement('div');
                            galleryItem.className = 'gallery-item';
                            
                            const thumbnailUrl = getThumbnailUrl(file.thumbnailLink);
                            const highResUrl = thumbnailUrl ? thumbnailUrl.replace(/=s\d+/, '=s1600') : `https://drive.google.com/uc?export=view&id=${file.id}`;

                            const imgElement = document.createElement('img');
                            imgElement.src = thumbnailUrl || `https://placehold.co/300x424/1a1a1a/4a4a5a?text=No+Thumb`;
                            imgElement.alt = file.name;
                            imgElement.onclick = () => addGameFromDrive(file.name, thumbnailUrl);

                            const viewIcon = document.createElement('div');
                            viewIcon.className = 'view-icon';
                            viewIcon.innerHTML = '&#128269;'; // Magnifying glass emoji
                            viewIcon.onclick = (e) => {
                                e.stopPropagation(); 
                                openDriveImageViewer(highResUrl, file.name);
                            };

                            const nameOverlay = document.createElement('div');
                            nameOverlay.className = 'image-name-overlay';
                            nameOverlay.textContent = file.name.replace(/\.[^/.]+$/, ""); // Clean name

                            galleryItem.appendChild(imgElement);
                            galleryItem.appendChild(viewIcon);
                            galleryItem.appendChild(nameOverlay);
                            driveGalleryContainer.appendChild(galleryItem);
                        });
                    } else {
                        showDriveMessage('No images found in this folder.');
                    }
                } catch (error) {
                    console.error('Error fetching images:', error);
                    showDriveMessage(`Error loading images: ${error.message}`, true);
                }
            }

            function addGameFromDrive(fileName, coverUrl) {
                const name = fileName.replace(/\.[^/.]+$/, "");

                if (allGames.some(game => game.name.toLowerCase() === name.toLowerCase())) {
                    console.warn(`Game "${name}" already exists in the library.`);
                    const existingCover = document.querySelector(`.cover-item[data-name="${name}"]`);
                    if (existingCover) {
                        existingCover.classList.add('in-wheel');
                        setTimeout(() => {
                            if (existingCover) existingCover.classList.remove('in-wheel');
                        }, 1000);
                    }
                    return;
                }

                const originalImage = new Image();
                originalImage.crossOrigin = "Anonymous"; 
                originalImage.onload = () => {
                    const resizeCanvas = document.createElement('canvas');
                    const targetWidth = 275;
                    const targetHeight = 387;
                    resizeCanvas.width = targetWidth;
                    resizeCanvas.height = targetHeight;
                    
                    const resizeCtx = resizeCanvas.getContext('2d');
                    resizeCtx.drawImage(originalImage, 0, 0, targetWidth, targetHeight);

                    const resizedCoverUrl = resizeCanvas.toDataURL('image/jpeg');
                    
                    const imageForWheel = new Image();
                    imageForWheel.onload = () => {
                        const newGame = {
                            name: name,
                            image: imageForWheel,
                            coverUrl: resizedCoverUrl
                        };
                        allGames.push(newGame);
                        if (!gamesInWheel.some(g => g.name === newGame.name)) {
                            gamesInWheel.push(newGame);
                        }
                        displayCoverInGallery(newGame);
                        saveGamesToStorage();
                        updateGalleryVisuals();
                        drawRoulette();
                        
                        driveGalleryModal.classList.add('hidden');
                    };
                    imageForWheel.src = resizedCoverUrl;
                };
                originalImage.onerror = () => {
                    console.error("Failed to load original image from Drive URL:", coverUrl);
                };
                originalImage.src = coverUrl;
            }

            function openDriveImageViewer(imageSrc, imageName) {
                viewerImg.src = imageSrc;
                viewerImg.alt = imageName;
                imageViewerModal.style.display = 'block';
            }

            // --- DRIVE GALLERY EVENT LISTENERS ---
            openDriveGalleryButton.addEventListener('click', () => {
                driveGalleryModal.classList.remove('hidden');
                loadDriveFolders();
            });

            driveBackButton.addEventListener('click', loadDriveFolders);

            closeDriveModalButton.addEventListener('click', () => {
                driveGalleryModal.classList.add('hidden');
            });

            driveGalleryModal.addEventListener('click', (e) => {
                if (e.target === driveGalleryModal) {
                    driveGalleryModal.classList.add('hidden');
                }
            });

            closeViewerBtn.addEventListener('click', () => {
                imageViewerModal.style.display = 'none';
            });

            imageViewerModal.addEventListener('click', (e) => {
                if (e.target === imageViewerModal) {
                    imageViewerModal.style.display = 'none';
                }
            });
        });
    </script>
</body>
</html>
